# June Daily Challenge
- [June Daily Challenge](#june-daily-challenge)
- [June 1st - June 7th](#june-1st---june-7th)
  - [256. Paint House(Medium)](#256-paint-housemedium)
  - [695. Max Area of Island](#695-max-area-of-island)
  - [505. The Maze II](#505-the-maze-ii)
  - [1696. Jump Game VI](#1696-jump-game-vi)

# June 1st - June 7th

## [256. Paint House(Medium)](https://leetcode.com/problems/paint-house/)

```java
Input: (int[][]) The cost of painting each house with a certain color(red, blue, or green) is represented by an n x 3 cost matrix costs.

Condiiont: No two adjacent houses have the same color

Output: (int) Return the minimum cost to paint all houses.
```

**Solution:**

First Method: Dynamic programming with n x 3 array. The reason for creating an additional array is to avoid to make a change on origina input array.

```java
class Solution {
    public int minCost(int[][] costs) {
        //dp
        int n = costs.length;
        int[][] dp = new int[n][3];
        dp[0][0] = costs[0][0];
        dp[0][1] = costs[0][1];
        dp[0][2] = costs[0][2];
        for(int i = 1; i < n; i++) {
            dp[i][0] = costs[i][0] + Math.min(dp[i - 1][1], dp[i - 1][2]);
            dp[i][1] = costs[i][1] + Math.min(dp[i - 1][0], dp[i - 1][2]);
            dp[i][2] = costs[i][2] + Math.min(dp[i - 1][0], dp[i - 1][1]);
        }
        return Math.min(dp[n - 1][0], Math.min(dp[n  - 1][1], dp[n - 1][2]));
    }
}
```
Time compleixity: **O(N)**  
Space complexity: **O(N)**

Second DP method: space complexity can be optimized by only using 3 varialbes to save the status of 3 colors.

```java
class Solution {
    public int minCost(int[][] costs) {
        int n = costs.length;
        int red = costs[0][0];
        int blue = costs[0][1];
        int green = costs[0][2];
        
        for(int i = 1; i < n; i++) {
            int tempR = red;
            red = costs[i][0] + Math.min(blue, green);
            int tempB = blue;
            blue = costs[i][1] + Math.min(tempR, green);
            green = costs[i][2] + Math.min(tempB, tempR);
        }
        return Math.min(red, Math.min(blue, green));
    }
}
```
Time complexity: **O(N)**
Space complexity: **O(1)**

## [695. Max Area of Island](https://leetcode.com/problems/max-area-of-island/)

Tag: dfs

```java
Input: (int[][]) 2D array, 1 represents island and 0 represents water.

Condition: An island is a group of 1's (representing land) connected 4-directionally (horizontal or vertical.) You may assume all four edges of the grid are surrounded by water.

Output: (int) Return the maximum area of an island in grid. If there is no island, return 0.
```

**Solution1: DFS(Recursive)**

```java
class Solution {
    public int maxAreaOfIsland(int[][] grid) {
        int res = 0;
        for(int i = 0; i < grid.length; i++) {
            for(int j = 0; j < grid[0].length; j++) {
                if(grid[i][j] == 1)
                    res = Math.max(res, dfs(grid, i, j));
            }
        }
        return res;
    }
    public int dfs(int[][] grid, int i, int j) {
        //base case
        if(i < 0 || i >= grid.length || j < 0 || j >= grid[0].length || grid[i][j] == 0)
            return 0;
        //change current value to 0 (marked as visited)
        grid[i][j] = 0;
        return 1 + dfs(grid, i + 1, j) + dfs(grid, i - 1, j) + dfs(grid, i, j + 1) + dfs(grid, i, j - 1);
    }
}
```

Time complexity: **O(R * N)**  
Space complexity: **O(1)**


**Solution2: DFS(Iterative)**

**(N/A)**


## 505. [The Maze II](https://leetcode.com/problems/the-maze-ii/)

```
Given the m x n maze, the ball's start position and the destination, where start = [startrow, startcol] and destination = [destinationrow, destinationcol], return the shortest distance for the ball to stop at the destination. If the ball cannot stop at destination, return -1.

Input: (int[][] maze, int[] start, int[] desitination)

Output: (int) return shortest distance for the ball to stop at the destination
```

**Solution: DFS**

```java
class Solution {
    //up, right, down, left
    private int[][] dirs = new int[][]{{0, 1}, {1, 0}, {0, -1}, {-1, 0}};
    public int shortestDistance(int[][] maze, int[] start, int[] destination) {
        //buid a 2d matrix to record shortest path to start position
        int[][] distance = new int[maze.length][maze[0].length];
        for(int[] row : distance) {
            Arrays.fill(row, Integer.MAX_VALUE);
        }
        //Start position intiated with 0
        distance[start[0]][start[1]] = 0;
        dfs(maze, start, distance);
        return distance[destination[0]][destination[1]] == Integer.MAX_VALUE ? -1 : distance[destination[0]][destination[1]];
    }
    public void dfs(int[][] maze, int[] start, int[][] distance) {
        for(int[] dir : dirs) {
            int x = start[0] + dir[0];
            int y = start[1] + dir[1];
            int count = 0;
            while(x >= 0 && x < maze.length && y >= 0 && y < maze[0].length && maze[x][y] == 0) {
                x += dir[0];
                y += dir[1];
                //update count
                count++;
            }
            if(distance[start[0]][start[1]] + count < distance[x - dir[0]][y - dir[1]]) {
                //update the shortest distance on current location
                distance[x - dir[0]][y - dir[1]] = distance[start[0]][start[1]] + count;
                dfs(maze, new int[]{x - dir[0], y - dir[1]}, distance);
             }
        }
    }
}
```

Time complexity: m * n (not sure)
Space complexity: m * n

## [1696. Jump Game VI](https://leetcode.com/problems/jump-game-vi/)

```
Input: (int[]) Given a 0-indexed integer array nums and an integer k.
Condition: In one move, you can jump at most k steps forward without going outside the boundaries of the array. That is, you can jump from index i to any index in the range [i + 1, min(n - 1, i + k)] inclusive.
Output: (int) Return the maximum score you can get.
```

Solution(Most efficient DP+Deque, but hard to understand): 

```java
class Solution {
    public int maxResult(int[] nums, int k) {
        int n = nums.length;
        // record the maximum score end at index i
        int[] dp = new int[n];
        //base case
        dp[0] = nums[0];
        Deque<Integer> dq = new LinkedList<>();
        dq.offer(0);
        for(int i = 1; i < n; i++) {
            //remove all the indices that smaller than i - k(out of range)
            while(!dq.isEmpty() && dq.peekFirst() < i - k) {
                dq.pollFirst();
            }
            //transition state equation
            dp[i] = nums[i] + dp[dq.peekFirst()];
            //remove all the smaller dp value from deque to maintain monotonically decreasing order
            while(!dq.isEmpty() && dp[dq.peekLast()] <= dp[i]) {
                dq.pollLast();
            }
            dq.addLast(i);
        }
        return dp[n - 1];
    }
}
```

Time complexity: **0(N)**
Space complexity: **O(N)**

Solution2(DP + PriorityQueue):

